-- При заполнении струкруры таблицы свойствами надо придерживаться следующих принципов
1. Является ли предполагаемое поле свойством сущности.
2. Однозначно ли значение этого свойства. 
Напр. в таблице курс MySQL создаём поле преподаватель:
1. преподаватель - свойство курса? Да.
2. Однозначно ли значение этого поля(напр. Иванов)? Нет, Ивановых много. Поэтому с этого поля надо создавать ссылку на таблицу преподавателей и там делать однозначность Иванова (его свойства)


--Создание регистронезависимой дб в utf8
CREATE DATABASE IF NOT EXISTS league COLLATE utf8_general_ci; 

--Создание регистрозависимого поля name в ut8 таблицы test
CREATE TABLE test
	(name VARCHAR(50) NOT NULL DEFAULT '' COLLATE utf8_bin );  
	
	
--Удаление таблицы, часто ставится перед созданием таблицы или дб	
DROP TABLE IF EXISTS test; 


--Создание таблицы с помощью описания	
CREATE TABLE test(
	id INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Код товара',
	code CHAR(4) NOT NULL DEFAULT 'aaaa',
	name VARCHAR(50) NOT NULL DEFAULT '' COMMENT 'Название товара',
	price FLOAT NOT NULL DEFAULT 0 COMMENT 'Цена товара'
	CONSTRAINT ctId PRIMARY KEY (id), --указание ограничения (первичный ключ) на дублирование
	CONSTRAINT ctCode UNIQUE KEY (code), --указание ограничения (уникальный ключ) на дублирование
	INDEX ixName (name),
	INDEX ixPrice (price) --создание индексов при создании таблицы (предпочтительный вариант)
) COMMENT 'Таблица товара с первичным ключом';

*************************************************************************************************************************************************

--Создание индекса для ускорения поиска, применяется к простым записям типов CHAR и VARCHAR
--Для полнотекстовых данных (типа TEXT) применяется FULLTEXT
--PRIMARY KEY и UNIQUE KEY автоматически индексируются
CREATE INDEX ixName ON test (name);--создаёт в таблице name поле индеков ixName, соответствующих данным поля name таблицы test
CREATE INDEX ixPrice ON test (price);
--Один из вариантов широкоприменяемого индекса
CREATE INDEX ixСheck ON users (login, password);	

--Удаление индекса
DROP INDEX ixPrice ON test;

--каждому индексу давать имя! начинающееся с ix

--индексируются:
- в первую очередь связи между таблицами(воркбэнч выставляет их автоматически), если они не являются PRIMARY KEY и UNIQUE KEY
- поля, учавствующие в WHERE =(<>). В LIKE и REGEXP не индексируются.
- поля, учавствующие в GROUP
- поля, учавствующие в ORDER


************************************************************************************************************************************************


--Создание таблицы test по образцу test2, копируется только структура таблицы но не данные
CREATE TABLE test LIKE test2
	

--Создание таблицы на основе запроса. Копируется и указанная структура, и данные таблицы.
--Созданная таблица не содержит ни первичного ключа, ни комментов.	Это как бы срез данных таблицы.
CREATE TABLE test COMMENT 'Результат запроса'
	SELECT club, name
		FROM leagues;
	
	
--Создание ВРЕМЕННОЙ (на время сессии или подключения к серверу) таблицы на основе запроса	
CREATE TEMPORARY TABLE test COMMENT 'Результат запроса'
	SELECT club, name
		FROM leagues;

		
--Удаление [ВРЕМЕННОЙ] таблицы
CREATE [TEMPORARY] TABLE IF EXISTS test [RESTRICT или CASCADE];
-- если RESTRICT, то не удалит пока не удалятся все связанные таблицы
-- если CASCADE, то сначало удалит все связанные таблицы, а потом указанную 

	
--Таблицы бд
DESC tables;

--Информационная БД: information_schema. Содержит таблицы с информацией обо всём на серваке.

--Список таблиц указанной БД
SELECT table_name, table_comment
	FROM information_schema.tables  
	WHERE table_schema = 'test';
	
--Спецификация колонок для таблицы test БД league
SELECT column_name, data_type, column_comment
	FROM information_schema.columns
	WHERE table_schema = 'league'
	AND table_name = 'test';
	
--Список БД
SELECT *
	FROM information_schema.schemata \G


	
--Связывание таблиц	через FOREIGN KEY 
CREATE TABLE parent (
	id INT UNSIGNED NOT NULL,
	PRIMARY KEY (id)
) ENGINE=INNODB;

CREATE TABLE child (
	id INT,
	parent_id INT UNSIGNED, --должен быть такого же типа INT UNSIGNED как и родительский id
	INDEX ixId (parent_id), --индексируем для создания и ускорения связи (поиска) с родительским id
	CONSTRAINT fkId FOREIGN KEY (parent_id) REFERENCES parent(id) --ограничение внешнего ключа ссылается на ключ id таблицы parent, т.е.проверяет есть ли среди id в таблице parent значение parent_id (есть ли соответствие связи).
	ON DELETE CASCADE --ограничение на удаление связанных записей, т.е. если удалять запись, то надо сначало удалить связанные записи в других таблицах
) ENGINE=INNODB;
	
	
--Добавление в таблицу 	test ряда с указанными значениями в порядке, в котором была создана таблица
INSERT INTO test 
	VALUES (NULL, 'Tовар1', 123),	-- id не указан(NULL), поэтому он сам сформируется если у него есть AUTO_INCREMENT. Но можно его задать, напр. 23.
		(NULL, 'Tовар2', 123),
		(NULL, 'Tовар3', 123);
	
	
--Добавление в таблицу 	test
INSERT INTO test (name, price)
	VALUES ('Товар1', 123.5),	-- значения неуказанных полей примут значения NOT NULL	DEFAULT (если его нет то NULL)
		('Tовар2', 123),
		('Tовар3', 123);
	
	
--Добавление в таблицу 	test ряда с указанными значениями в порядке, в котором была создана таблица
INSERT IGNORE INTO test 
	VALUES (12, 'Tовар1', 123),	-- если id=12 уже есть то эта запись игнорируется IGNORE(пропускается), а остальные вставляются. Без IGNORE все записи после ошибочной проигнорируются.
		(23, 'Tовар2', 123),
		(24, 'Tовар3', 123);	

		
--(для движка MyISAM, на InnoDB не работает) отключение индексирования на время массированного добавления данных чтобы не задерживаться на пересчёт индексов после добавления каждой строчки. В том числе и на автоматическое индексирование PRIMARY KEY.
--применяется при разовом добавлении более 1000 строк.
ALTER TABLE test DISABLE KEYS;
INSERT IGNORE INTO test VALUES .....;
--включение индексирования после добавления данных. При этом индексирование данных осуществляется за 1 проход.	
ALTER TABLE test ENABLE KEYS;	
	

--для быстрой загрузки на сервак огромного кол-ва данных (миллионы строк)
--предварительно создаётся текстовый файл данных со строками данных, соответствующих значениям полей будущей таблицы	
LOAD DATA
	INFILE 'C:/Documents/data.txt'
	INTO TABLE test
	FIELDS TERMINATED BY '\t'    --поля в текстовом доке разделены \t
	LINES TERMINATED BY '\r\n';  --линии или строки разделены \r\n

--для задания приоритета выполнения запроса можно задать 
INSERT LOW_PRIORITY [или DELAYED или HIGH_PRIORITY] IGNORE INTO test VALUES .....;
LOAD DATA LOW_PRIORITY [или CONCURRENT]....
DELETE LOW_PRIORITY ...
DELETE QUICK ... --отложенное удаление, пометить записи на удаление и удалить когда сможет

	
--Удаление всех записей таблицы
DELETE FROM test;

--удаление конкретных записей
DELETE FROM test
	WHERE id = 1;

DELETE IGNORE ... --удалит все перечисленные записи, кроме той, которой удаление запрещено (напр из-за 	FOREIGN KEY связанную запись).
-- без IGNORE будет удалять записи до тех пор, пока не наткнётся на конфликтную.

--Удаление послндней записи
DELETE FROM test
	ORDER BY id DESC -- отсортируй id в порядке DESC - убывания(в оьратном порядке) 
	LIMIT 1; -- возьми 1 запись (строку).
	

--Обновление записей таблицы
UPDATE test
	SET
		name = CONCAT(name, ' *'), -- поле = новая запись(склеенная)
		price = price * 1.5
	WHERE id BETWEEN 10 AND 30; --фильтр записей


	
--	http://dev.mysql.com/doc/refman/ - информация о языке, встроенные функции, операторы и т.д.
	
********************************************************************************************************************

-- SQL VIEW - чтобы не повторять часто одни и те же запросы SELEST на просмотр таблицы, эти запросы можно сохранить как объект SQL и потом вызывать его. И этот объект представляет собой таблицу, составленную на основе запроса.
-- данные в таблице VIEW не хранятся, это как бы виртуальная таблица ссылок на реальные таблицы. Но работать с ней можно как с обычной таблицей с данными.
-- SQL VIEW - это сохранённый запрос. Он кэшируется сервером, поэтому он работает намного быстрее, чем обращение к обычной таблице.

DROP VIEW IF EXISTS currCourses;    --удаление просмотра перед ешо созданием
CREATE VIEW currCourses AS          --создать объект запроса currCourses 
	SELECT DISTINCT course          --из следующего запроса
		FROM lessons
		WHERE MONTH(lesson_date) = 9
		AND YEAR(lesson_date) = 2006;
		
SELECT * FROM currCourses; -- вывод таблицы объекта запроса 

*****************************************************************************************************************************************************************************

-- БЛОКИРОВКИ ТАБЛИЦ LOCK (примитивный и устаревший способ, лучше пользоваться транзакциями)

-- Блокировка на запись LOCK READ. Пользователи могут читать заблокированную таблицу, но не могут модифицировать пока не запустится UNLOCK.
LOCK TABLES test READ;
[запросы]
UNLOCK TABLES;

-- Блокировка на обращение к таблице (и на модификацию, и на чтение) LOCK WRITE.

LOCK TABLES test WRITE;
[запросы]
UNLOCK TABLES;

-- Объединённый пример	

LOCK TABLES test1 READ, test2 WRITE;
[запросы]
UNLOCK TABLES;	

**********************************************************************************************************************************************************************************************

-- Транзакция - это логический модуль (запросов, модификаций таблиц, выражений и т.д.), который должен выполниться или целиком, или не выполниться вообще. В случае частичного выполнения(напр. сбой) модуль должен сброситься ROLLBACK и не производить никаких изменений в бд. Все изменения бд производятся только после поступления сигнала об успешном завершении всего модуля (транзакции) COMMIT.
-- В случае одновременного выполнения транзакций с обращением к одному ресурсу, первая транзакция включает LOCK на этот ресурс и другие транзакции не могут к нему обратиться, пока не поступит результат о выполнении первой транзакции.(смотри ISOLATION дальше).
-- Результат транзакции(даже если она завершилась) не должен нарушать правила системы (главног модуля) и если он нарушает, то сигнал об успешном завершении транзакции не поступает и изменения в бд не вносятся.

SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL READ COMMITTED; -- уровень изоляции транзакции от параллельных
START TRANSACTION;  -- старт транзакции
	SELECT id, name FROM teachers;
	INSERT INTO teachers (id, name) VALUES (11, 'Новый препод');  -- вносим изменения в таблицу (создаётся временная таблица (или журнал операций) и там вносятся изменения, после подтверждения COMMIT об успешности транзакции данные временной таблицы (или журнала операций) будут перенесены в оригинальную)
	DELETE FROM teachers WHERE id = 11;                           -- при этом таблица teachers будет заблокирована временно для других транзакций и операций запросов к ней
[ROLLBACK;]         -- отмена транзакции
[COMMIT;]           -- подтверждение успешности транзакции

-- Движок InnoDB автоматически включает транзакции на все запросы, т.е. инсерты, делиты и т.д работают с START TRANSACTION-COMMIT, что перегружает сервер особенно с тысячами инсертов или апдейтов. 
-- Поэтому лучше в таких случаях отключать транзакции в InnoDB и прогонять эти тысячи инсёртов в одном блоке-транзакции START TRANSACTION-COMMIT вручную

-- По умолчанию параметр транзакции в InnoDB включен AUTOCOMMIT = 1;
-- Отключение:
SET AUTOCOMMIN = 0;

--Пример генератор матчей. Делается в транзакции и все инсёрты координат загоняются в таблицу матча вручную одним блоком транзакцией. После чего включается параметр автокоммит = 1.

--В транзакциях можно задавать уровень доступа(изоляции) других параллельных транзакций к изменённым ресурсам в первой транзакции 
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; -- без ограничений - во время второй транзакции видны изменения ресурсов незавершенной первой транзакции
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL READ COMMITTED;   -- во время второй транзакции видны изменения ресурсов завершенной первой транзакции
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL REPEATABLE READ;  -- по умолчанию (рекомендуется), во время второй транзакции изменения ресурсов другой транзакцией не видны вообще. Т.е. если одновременно будут запущены 2 транзакции, то на выходе их будет одинаковый результат, т.к. изменения в ресурсах  в первой транзакции не передадутся во вторую и та продублирует первую транзакцию. И только после коммит первой транзакции вступят в силу изменения ресурсов и уже последующие транзакции будут пользоваться изменёнными ресурсами.

***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
	
-- ДВИЖКИ или способы хранения данных MySQL	

-- Задание движка (при создании таблицы)
CREATE TABLE t ENGINE = INNODB (); -- или синоним TYPE = INNODB

-- Изменение движка на существующей таблице
ALTER TABLE t ENGINE = MYISAM; -- (или синоним TYPE = ...) но не всегда если есть противоречия, напр. FOREIGN KEY


***INNODB (включен по умолчанию).

Хранятся не в папке БД, а папкой выше(по умолчанию) или в спец папке, указываемой при установке сервера как место хранения данных InnoDB

--Папки
ibdata1 - тут хранятся данные БД
ib_logfile0 и ib_logfile1 - журналы транзакций

--Плюсы:
-быстрый движок и полная поддержка всех возможностей сервера MySQL
-поддержка транзакций
-быстрый на SELECT
-рекомендуется по умолчанию

--Минусы:
-не поддерживает полнотекстовые индексы FULLTEXT


***MYISAM и MERGE

Хранятся в виде отдельных таблиц-файликов в общей папке БД.
Структура
-[name].frm - структкра таблицы
-[name].MYD - значения таблицы
-[name].MYI - индексы таблицы
В MERGE [name].MYD склеиваются в один большой файл

--Плюсы
-самая быстрая модификация данных БД (инсерт-апдейт-делейт) в разы быстрее, чем INNODB
-не требователен к ресурсам сервера
-есть полнотекстовые индексы FULLTEXT

--Минусы
-в разы медленнее выполняет запросы выборки данных SELECT, чем INNODB 
-не поддерживает внешние связи через FOREIGN KEY
-не поддерживает транзакции, но есть LOCK

Рекоиендуется использовать если в таблицу очень часто заносятся новые записи (напр. комментарии), тогда таблицу делать в 1-й норм форме.
И при полнотекстовом поиске.


***ARCHIVE - предназначен только для хранения, потому что любые модификации данных проходят крайне медленно, но выборку селектом делает как MYISAM
Хранит данные в виде ZIP-архива в разы сжимая данные по сравнению с MYISAM
Структура:
[name].frm - структура таблицы
[name].ARZ - архив данных


***CSV - данные хранятся в текстовом формате построчно через запятую(старый формат хранения)
Структура:
[name].frm - структура таблицы
[name].CSV - данные таблицы
[name].CSM - справочный файл
Скорость выборки селектом соизмерима с MYISAM
--Минусы
-не поддерживает внешние связи через FOREIGN KEY
-не поддерживает транзакции
-не поддерживает полнотекстовые индексы FULLTEXT


***MEMORY - хранит все данные в оперативной памяти машины
Рекомендуется использовать для временных таблиц.
Работает в десятки раз быстрее других движков.


***BLACKHOLE - всю записываемую информацию тут же уничтожает, т.е. запись пустых данных. Используется для отладки.
