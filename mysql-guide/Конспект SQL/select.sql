--Единица измерения mysql - таблица. SELECT всегда возвращает таблицу.

--Вывод значения
SELECT 2 + 2;
-- выведет таблицу с полем 2 + 2 и записью в нём 4
----------
| 2 + 2 |
----------
|   4   |
----------

--Задание переменной
SET @a = 'Привет!'; -- в таблице переменных на время сеанса заносится в поле @a значение Привет! 
SELECT @a;
----------
|  @a    |
----------
| Привет!|
----------

--Вывод значения с заданием наименования поля в котором будет это значение
SELECT 2 + 2 AS summm;
----------
|  summ  |
----------
|   4    |
----------

--Выбор данных полей из таблицы
SELECT name, login
	FROM users;
	
--Выбор данных полей из таблицы и переименование полей выводимой( не той с которой берутся данные) таблицы
SELECT name AS teacher, login AS user_name
	FROM users;

--Выбор данных полей из таблицы, сортируя данные поля 
SELECT name, login
	FROM users;
	ORDER BY name; --сортировка выводимой таблицы по полю name в алфавитном порядке или по возрастанию
	[ORDER BY name ASC;] -- в порядке возрастания, стоит по умолчанию
	[ORDER BY name DESC;] -- убывания
	[ORDER BY 2;] -- в крайних случаях используется порядковый номер поля
	LIMIT 5; --ограничение числа записей, т.е. выбрать только первые 5 записей
	[LIMIT 3,5;] --выбрать только после 3-й записи поля name (в ORDER BY name;) 5 записей
	
	
--Выбор данных полей из таблицы с указанием фильтра WHERE	
SELECT name, login
	FROM users;
	WHERE name = 'Alex';
	[NOT name = 'Alex';] --имя не равно Alex
	[WHERE id > 5;]
	ORDER BY name DESC; --сортируя выводимую таблицу по полю name по убыванию
	[WHERE id BETWEEN 5 AND 7] - короткий аналог записи WHERE id >= 5 AND id <= 7


	
--Выбор данных неповторяющихся данных полей из таблицы (повторяющиеся данные отбрасываются и заменяются одним значением)
SELECT DISTINCT name FROM test;
-- и из поля name со значениями 1,3,3,5,7,6,7,8,8 выведет 1,3,5,6,7,8	
--противоположность DISTINCT
SELECT ALL... -- но ALL уже стоит в SELECT по умолчанию	
	

--NULL - значит не записано данных в ячейку или отсутствие записи
--Проверка на отсутствие записи IS NULL(проверка на пустоту)
SELECT name, login
	FROM users;
	WHERE name IS NULL; --вывести строки, у которых значения поля name пустые (NULL) 



--Выбор данных полей из таблицы c фильтром части строки
SELECT name
	FROM users;
	WHERE name LIKE '%le%';	 --выведет допустим Alex
	-- '%' -заменяет любое число символов
	-- '_' -заменяет один символ
	
--Поиск данных с помощью регулярных выражений REGEXP	
SELECT name
	FROM users;
	WHERE name REGEXP '^[0-9].........';	
	
-- ни LIKE, ни REGEXP не используют индексов и осуществляют поиск простым перебором, что очень ресурсоёмко


--Выбор данных полей из таблицы c фильтром WHERE IN
SELECT name, login
	FROM users
	WHERE name IN('Alex', 'algerd', 'igrex'); -- что равносильно OR для name = ['Alex', 'algerd', 'igrex']
-- в скобках IN могут быть запросы SELECT на значения
    [WHERE name NOT IN ('Alex', 'algerd', 'igrex');] --в name нет одного из строкового значения или 'Alex' или 'algerd' или 'igrex'
	

-- Все выражения для SELECT подходят и для DELETE, и для UPDATE

--Выбор данных полей из таблицы c фильтром WHERE IN c помощью встроенных функций
SELECT DISTINCT YEAR(lesson_date), MONTH(lesson_date) --выбрать неповторяющиеся значения года и месяца с поля lesson_date таблицы lessons, которым соответствует одно из значений 1, 3, 5 поля teacher
	FROM lessons
	WHERE teacher IN(1, 3, 5);

--Добавление интервала времени к дате с помощью встроенных функций
SELECT DATE_ADD('2008-01-02', INTERVAL 31 DAY);
SELECT DATE_ADD(NOW(), INTERVAL 100 DAY);


--Объединение запросов
SELECT a 
	FROM t1
	WHERE a=10 AND b=1
UNION                     -- без дублирования строк
[UNION ALL]               -- с дублированием строк
SELECT a
	FROM t2
	WHERE a=11 AND b=2
ORDER BY a;               -- сортировка результирующего запроса
-- Выведет таблицу с полем a (если имя поля совпадает в обоих селектах, если нет то поле будет безымянным с простым порядковым номером напр. 1 или 2), в которой по порядку будут идти данные с первого и второго селекта.
-- Он автоматически тсключает дублирование строк аналогично DISTINCT, чтобы разрешить дублирование ставится UNION ALL
тавится 
-- Подробно стр.178 у Грабера.


--Операторы, которые в качестве аргумента принимают только подзапрсы (стр.155 у Грабера)
EXISTS(подзапрос) - проверяет наличие данных в подзапросе и возвращает TRUE или FALSE
[NOT EXISTS(подзапрос)]
ANY(подзапрос) -- его синоним SOME, аналогичен IN - проверяет соответствие хотя бы одному значению из множества (OR)
ALL(подзапрос) -- проверяет соответствие всем значениям из множества (AND)

SELECT * 
	FROM salespeople
	WHERE city = ANY
		(SELECT city
			FROM customers); -- оператор ANY принимает все значения подзапроса(значения поля city) и обращается в true если хотя бы одно из них равно текущему значению поля city внешнего запроса.
-- IN применяеися и для подзапросов и для множества простых значений.

*******************************************************************************************************************************************************************************************************************


--Поиск на движке MyISAM
--Создание копии таблицы на движке MyISAM
CREATE TABLE courses1 ENGINE=MyISAM SELECT * FROM course.courses;
--Создание полнотекстовых индексов
CREATE FULLTEXT INDEX ixFullText ON courses1 (title, name);
--Поиск в таблице courses1 в индексированном склеенном поле (title, name) ячейки, в тексте которой есть слово Алекс
SELECT tittle, login
	FROM courses1
	WHERE MATCH (title, name)
		AGAINST ('Алекс' IN NATURAL LANGUAGE MODE);         -- в режиме естественного языка
		[AGAINST ('+Алекс +Иго* -algerd' IN BOOLEAN MODE)]; -- в режиме логического языка: +Алекс - присутствует слово Алекс, -algerd - отсутствует слово algerd, +Иго* - присутствует часть слова Иго и т.д.

--Поиск в смешанном режиме (сортировка в режиме естественного языка, фильтрация в логическом режиме)
--Логический режим с сортировкой по релевантности (близости к запрашиваемому слову)
SELECT tittle, login,  
    MATCH (title, name) AGAINST ('word1 word2 word3' IN NATURAL LANGUAGE MODE) AS score
	FROM courses1
	WHERE MATCH (title, name)		       
		AGAINST ('word1 word2 word3' IN BOOLEAN MODE)
	ORDER BY score DESC;
		
-- в my.ini параметр минимальной длины слова полнотекстового поиска	
[mysqld]		
ft_min_word_len=3

--Переиндексация таблицы 
REPAIR TABLE  courses1 QUICK;
		

************************************************************************************************************************************************************************************************************		

--Встроенные функции агрегации - из множества значений поля(полей) выбирает или создаёт одно значение.
SELECT COUNT(*) FROM test; --кол-во рядов таблицы test!
SELECT MAX(age) FROM students; --max значение из данных поля age


--Группировка данных. Если в каком-то поле есть повторяющиеся данные, то по ним можно сделать группировку.
SELECT teacher, SUM(hours)
	FROM lessons
	GROUP BY teacher  -- выведет сгруппированную таблицу по полю teacher(в нём будут только неповторяющиеся значения) и этим значениям будут соответствовать сумма часов hours повторяющихся teacher
	[GROUP BY teacher WITH ROLLUP] -- c дополнительной итоговой строчкой
--то что написано в GROUP BY написано в SELECT
	
teacher! hours                           teacher !  SUM
-----------------                    -----------------------
иванов ! 4                                иванов !  10
петров ! 3                                петров !  8
иванов ! 6                  =>           [ NULL  !  18  ]       -- WITH ROLLUP (SUM(сгруппированных данных - сумм))
петров ! 5                           -----------------------
----------------

--Множественная группировка
SELECT teacher, course SUM(hours)
	FROM lessons
	GROUP BY teacher, course -- группировка по повторяющимся значениям полей teacher, course

--Группировка по выражению
SELECT YEAR(lesson_date), MONTH(lesson_date), SUM(hours)
	FROM lessons
	GROUP BY YEAR(lesson_date), MONTH(lesson_date);

--Группировка с предварительной фильтрацией, т.е. сначала фильтрует по WHERE а потом отфильтрованную таблицу группирует
SELECT YEAR(lesson_date), MONTH(lesson_date), SUM(hours)
	FROM lessons
	WHERE teacher IN('иванов','петров')  --фильтрация таблицы по иванову и петрову
	GROUP BY YEAR(lesson_date), MONTH(lesson_date) [WITH ROLLUP]; --группировка отфильтрованной таблицы

--Группировка с постфильтрацией, т.е. сначало сгруппирует таблицу, а потом отфильтрует по HAVING
SELECT YEAR(lesson_date), MONTH(lesson_date), SUM(hours)
	FROM lessons
	WHERE teacher IN('иванов','петров')  --фильтрация таблицы по иванову и петрову
	GROUP BY YEAR(lesson_date), MONTH(lesson_date) [WITH ROLLUP]; --группировка отфильтрованной таблицы
	HAVING SUM(hours)>10;  --фильтрация сгруппированной таблицы
	
SELECT teacher, course, SUM(hours)	
	FROM lessons
	GROUP BY teacher, course WITH ROLLUP
	HAVING course IS NULL;
	
*****************************************************************************************************************

--Рекомендуемый порядок написания предикатов (порядок обработки сервером)
WHERE
GROUP
HAVING
ORDER
LIMIT	
	
	
	
	
	
	
	
	

		